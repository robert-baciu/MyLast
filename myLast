#!/bin/bash

# parsarea argumentelor
while [[ $# -gt 0 ]]; do
    case $1 in
        -n|--limit)
            ARG_LIMIT="$2"
            shift 2
            ;;
        -p|--present)
            ARG_PRESENT="$2"
            shift 2
            ;;
        -s|--since)
            ARG_SINCE="$2"
            shift 2
            ;;
        -t|--until)
            ARG_UNTIL="$2"
            shift 2
            ;;
    esac
done

if [[ -n $ARG_LIMIT ]]; then
    # -n
    # Tell last how many lines to show.
    LOGINS_LINE_LIMIT="$ARG_LIMIT"
fi

if [[ -n $ARG_PRESENT ]]; then
    # -p
    # Display the users who were present at the specified time.
    # This is like using the options --since and --until together with the same time.
    LOGINS_PRESENT=$(date -d "$ARG_PRESENT" +%s)    
fi

if [[ -n $ARG_SINCE ]]; then
    # -s
    # Display the state of logins since the specified time.
    LOGINS_SINCE=$(date -d "$ARG_SINCE" +%s)
fi

if [[ -n $ARG_UNTIL ]]; then
    # -t
    # Display the state of logins until the specified time.
    LOGINS_UNTIL=$(date -d "$ARG_UNTIL" +%s)
fi

LOG_FILES="/var/log/auth.log*" 

zcat -f $LOG_FILES \
| grep "pam_unix(gdm-password:session): session" \
| sort -r \
| while read ISO_DATE MSG; do
	if [[ $MSG == *opened* ]]; then
        # sesiune deschisa
        if [[ -n $LOGINS_LINE_LIMIT ]]; then
            if [[ $LOGINS_LINE_LIMIT -gt 0 ]]; then
                LOGINS_LINE_LIMIT=$((LOGINS_LINE_LIMIT - 1))
            else
                break
            fi
        fi

        OPEN_DATE=$(date -d "$ISO_DATE" "+%a %b %d %H:%M")
        OPEN_EPOCH=$(date -d "$ISO_DATE" +%s)

#daca este activ argumentul -p va afisa linia doar daca este ziua ceruta

	if [[ -n $LOGINS_PRESENT ]]; then
               if [[ $OPEN_EPOCH -ge $LOGINS_PRESENT && $OPEN_EPOCH -lt $((LOGINS_PRESENT + 86400)) ]]; then
                       :
		else
			continue #cauta in continuare
               fi
        fi


        if [[ -n $LOGINS_SINCE ]]; then
            if [[ $OPEN_EPOCH -lt $LOGINS_SINCE ]]; then 
			break
	    fi
        fi

        if [[ -n $LOGINS_UNTIL ]]; then
		if [[ $OPEN_EPOCH -gt $LOGINS_UNTIL ]]; then 
			continue  #trece la urmatoarea linie, o ignora pe cea prezenta

		fi
        fi


        USER=$(echo $MSG | grep -Eo "user (\w+)" | awk '{print $2}')

        if [[ -z $CLOSE_ISO_DATE ]]; then
            # sesiune deschisa, neincheiata
            echo "$USER  tty2  tty2  $OPEN_DATE   still logged in"
        else
            # sesiune deschisa, incheiata
            CLOSE_DATE=$(date -d "$CLOSE_ISO_DATE" "+%H:%M")
            CLOSE_EPOCH=$(date -d "$CLOSE_ISO_DATE" +%s)
            DURATION_EPOCH=$((CLOSE_EPOCH - OPEN_EPOCH))
            DURATION_DAYS=$((DURATION_EPOCH / 86400))
            DURATION=$(date -u -d "@$DURATION_EPOCH" +"%H:%M")

            if [[ $DURATION_DAYS == 0 ]]; then
                echo "$USER  tty2  tty2  $OPEN_DATE - $CLOSE_DATE ($DURATION)"
            else
                echo "$USER  tty2  tty2  $OPEN_DATE - $CLOSE_DATE ($DURATION_DAYS+$DURATION)"
            fi
        fi
	elif [[ $MSG == *closed* ]]; then
        # sesiune inchisa
		CLOSE_ISO_DATE=$ISO_DATE
	fi
done
